<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCP Tools - Volcano SDK</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
  <noscript><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet"></noscript>
  <link rel="stylesheet" href="https://unpkg.com/prismjs@1.29.0/themes/prism-tomorrow.min.css"/>
  <script src="https://unpkg.com/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@1.29.0/components/prism-clike.min.js"></script>
  <script src="https://unpkg.com/prismjs@1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://unpkg.com/prismjs@1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://unpkg.com/prismjs@1.29.0/components/prism-bash.min.js"></script>
</head>
<body>
  <div class="layout">
    <!-- Sidebar Navigation -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <a href="index.html" class="logo">
          <span class="emoji">üåã</span>
          <span class="text">Volcano SDK</span>
        </a>
      </div>
      
      <nav class="sidebar-nav">
        <div class="nav-section">
          <div class="nav-section-title">Getting Started</div>
          <a href="index.html#introduction" class="nav-link">Introduction</a>
          <a href="index.html#installation" class="nav-link">Installation</a>
          <a href="index.html#quick-start" class="nav-link">Quick Start</a>
          <a href="index.html#use-cases" class="nav-link">Use Cases</a>
          <a href="index.html#comparison" class="nav-link">Volcano vs Others</a>
          <a href="index.html#core-concepts" class="nav-link">Core Concepts</a>
          <a href="examples.html" class="nav-link">Examples</a>
          <a href="index.html#questions" class="nav-link">Questions & Requests</a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">Providers</div>
          <a href="providers.html" class="nav-link">Overview</a>
          <a href="providers.html#openai" class="nav-link">OpenAI</a>
          <a href="providers.html#anthropic" class="nav-link">Anthropic (Claude)</a>
          <a href="providers.html#mistral" class="nav-link">Mistral</a>
          <a href="providers.html#llama" class="nav-link">Llama</a>
          <a href="providers.html#bedrock" class="nav-link">AWS Bedrock</a>
          <a href="providers.html#vertex" class="nav-link">Google Vertex Studio</a>
          <a href="providers.html#azure" class="nav-link">Azure AI</a>
          <a href="providers.html#custom" class="nav-link">Custom Provider</a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">MCP Tools</div>
          <a href="mcp-tools.html" class="nav-link active">Overview</a>
          <a href="#automatic" class="nav-link">Automatic Selection</a>
          <a href="#explicit" class="nav-link">Explicit Calling</a>
          <a href="#authentication" class="nav-link">Authentication</a>
          <a href="#connection-pooling" class="nav-link">Connection Pooling</a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">Advanced Patterns</div>
          <a href="patterns.html" class="nav-link">Overview</a>
          <a href="patterns.html#multi-llm" class="nav-link">Multi-LLM Workflows</a>
          <a href="patterns.html#parallel" class="nav-link">Parallel Execution</a>
          <a href="patterns.html#branching" class="nav-link">Conditional Branching</a>
          <a href="patterns.html#loops" class="nav-link">Loops</a>
          <a href="patterns.html#sub-agents" class="nav-link">Sub-Agent Composition</a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">Features</div>
          <a href="features.html" class="nav-link">Overview</a>
          <a href="features.html#run" class="nav-link">run() Method</a>
          <a href="features.html#streaming" class="nav-link">stream() Method</a>
          <a href="features.html#retries" class="nav-link">Retries & Timeouts</a>
          <a href="features.html#hooks" class="nav-link">Step Hooks</a>
          <a href="features.html#errors" class="nav-link">Error Handling</a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">API Reference</div>
          <a href="api.html" class="nav-link">Overview</a>
          <a href="api.html#agent" class="nav-link">agent()</a>
          <a href="api.html#step" class="nav-link">Step Types</a>
          <a href="api.html#results" class="nav-link">Step Results</a>
        </div>
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="content">
      <div class="content-inner">
        <section class="doc-section">
          <h1>MCP Tools</h1>
          <p class="lead">The Model Context Protocol (MCP) enables AI agents to securely interact with external tools and data sources. Volcano SDK provides first-class MCP integration with automatic tool discovery, selection, and authentication.</p>
          
          <div class="highlight-box blue">
            <strong>What is MCP?</strong> The Model Context Protocol is an open standard for connecting AI systems to external data sources and tools. It enables LLMs to safely interact with databases, APIs, file systems, and other services through a unified interface.
          </div>
        </section>

        <!-- Automatic Tool Selection -->
        <section id="automatic" class="doc-section">
          <h2>Automatic Tool Selection</h2>
          <p>Let the LLM intelligently choose which tools to call based on the prompt. This is the recommended approach for most use cases.</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">import { agent, llmOpenAI, mcp } from "volcano-sdk";

const weather = mcp("http://localhost:3000/mcp");
const notifications = mcp("http://localhost:4000/mcp");
const llm = llmOpenAI({ apiKey: process.env.OPENAI_API_KEY! });

await agent({ llm })
  .then({
    prompt: "Check SF weather for tomorrow and send me a notification.",
    mcps: [weather, notifications]
  })
  .run();

// The LLM automatically:
// 1. Discovers available tools from both servers
// 2. Selects the appropriate tools
// 3. Calls them with correct arguments
// 4. Returns the results</code></pre>
          </div>

          <h3>How It Works</h3>
          <ul class="benefits-list">
            <li><strong>Tool Discovery:</strong> Volcano fetches available tools from MCP servers (cached with TTL)</li>
            <li><strong>LLM Selection:</strong> The LLM analyzes the prompt and chooses relevant tools</li>
            <li><strong>Schema Validation:</strong> Arguments are validated against JSON Schema before execution</li>
            <li><strong>Iterative Calling:</strong> The LLM can make multiple tool calls in sequence (up to 4 iterations)</li>
            <li><strong>Context Flow:</strong> Tool results are automatically included in subsequent steps</li>
          </ul>

          <h3>Multiple MCP Servers</h3>
          <p>Provide multiple MCP servers and the LLM will use tools from any of them:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">const database = mcp("http://localhost:5000/mcp");
const email = mcp("http://localhost:5001/mcp");
const analytics = mcp("http://localhost:5002/mcp");

await agent({ llm })
  .then({
    prompt: "Query user data, analyze it, and email the report to admin@example.com",
    mcps: [database, email, analytics]
  })
  .run();

// The LLM automatically orchestrates tools across all three servers</code></pre>
          </div>
        </section>

        <!-- Explicit Tool Calling -->
        <section id="explicit" class="doc-section">
          <h2>Explicit Tool Calling</h2>
          <p>Call specific MCP tools directly when you know exactly which tool to use and with what arguments.</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">const cafe = mcp("http://localhost:3000/mcp");

await agent({ llm })
  .then({ prompt: "Recommend a coffee for Ava from Naples" })
  .then({ 
    mcp: cafe, 
    tool: "order_item", 
    args: { item_id: "espresso", quantity: 2 } 
  })
  .run();</code></pre>
          </div>

          <h3>With LLM Step</h3>
          <p>Combine LLM reasoning with explicit tool calls:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">await agent({ llm })
  .then({ 
    mcp: database,
    tool: "query_users",
    args: { status: "active" },
    prompt: "Analyze the results and summarize"  // LLM processes tool output
  })
  .run();</code></pre>
          </div>

          <h3>When to Use Explicit Calling</h3>
          <ul>
            <li>You know exactly which tool to call</li>
            <li>The arguments are predetermined</li>
            <li>You want fine-grained control over execution order</li>
            <li>You're building deterministic workflows</li>
          </ul>
        </section>

        <!-- Authentication -->
        <section id="authentication" class="doc-section">
          <h2>MCP Authentication</h2>
          <p>Volcano SDK supports OAuth 2.1 and Bearer token authentication per the MCP specification. Authentication can be configured at the MCP handle level or centrally at the agent level.</p>
          
          <h3>Handle-Level Authentication</h3>
          <p>Configure auth directly on the MCP handle:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">// OAuth on handle
const protectedMcp = mcp("https://api.example.com/mcp", {
  auth: {
    type: 'oauth',
    clientId: process.env.MCP_CLIENT_ID!,
    clientSecret: process.env.MCP_CLIENT_SECRET!,
    tokenEndpoint: 'https://api.example.com/oauth/token'
  }
});

// Bearer token on handle  
const bearerMcp = mcp("https://api.example.com/mcp", {
  auth: {
    type: 'bearer',
    token: process.env.MCP_BEARER_TOKEN!
  }
});</code></pre>
          </div>

          <h3>Agent-Level Authentication</h3>
          <p>Configure auth centrally at the agent level for cleaner code when using multiple authenticated servers:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">// MCP handles without auth
const mcp1 = mcp("https://api.example.com/mcp");
const mcp2 = mcp("https://api.other.com/mcp");

// Auth configured at agent level
await agent({
  llm,
  mcpAuth: {
    'https://api.example.com/mcp': {
      type: 'oauth',
      clientId: process.env.CLIENT_ID_1!,
      clientSecret: process.env.CLIENT_SECRET_1!,
      tokenEndpoint: 'https://api.example.com/oauth/token'
    },
    'https://api.other.com/mcp': {
      type: 'bearer',
      token: process.env.TOKEN_2!
    }
  }
})
  .then({ prompt: "Use tools from both servers", mcps: [mcp1, mcp2] })
  .run();</code></pre>
          </div>

          <div class="info-box tip">
            <div class="info-icon">üí°</div>
            <div>
              <strong>Precedence:</strong> Handle-level auth takes precedence over agent-level auth. This allows you to set defaults at the agent level and override for specific handles.
            </div>
          </div>

          <h3>OAuth Authentication (Client Credentials)</h3>
          <p>Recommended for production MCP servers. Volcano automatically acquires and refreshes tokens:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">const protectedMcp = mcp("https://api.example.com/mcp", {
  auth: {
    type: 'oauth',
    clientId: process.env.MCP_CLIENT_ID!,
    clientSecret: process.env.MCP_CLIENT_SECRET!,
    tokenEndpoint: 'https://api.example.com/oauth/token'
  }
});

await agent({ llm })
  .then({ 
    prompt: "Use protected tools",
    mcps: [protectedMcp]
  })
  .run();

// Volcano automatically:
// 1. Requests OAuth token from tokenEndpoint
// 2. Caches the token until expiration
// 3. Refreshes automatically when needed
// 4. Includes Authorization header in all requests</code></pre>
          </div>

          <h3>Bearer Token Authentication</h3>
          <p>For pre-acquired tokens or custom authentication flows:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">const authMcp = mcp("https://api.example.com/mcp", {
  auth: {
    type: 'bearer',
    token: process.env.MCP_BEARER_TOKEN!
  }
});

await agent({ llm })
  .then({ mcp: authMcp, tool: "secure_action", args: {} })
  .run();</code></pre>
          </div>

          <h3>Mixed Authentication</h3>
          <p>Combine authenticated and non-authenticated MCP servers in the same workflow:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">const publicMcp = mcp("http://localhost:3000/mcp");  // No auth
const privateMcp = mcp("https://api.example.com/mcp", {
  auth: {
    type: 'oauth',
    clientId: process.env.CLIENT_ID!,
    clientSecret: process.env.CLIENT_SECRET!,
    tokenEndpoint: 'https://api.example.com/oauth/token'
  }
});

await agent({ llm })
  .then({ mcp: publicMcp, tool: "get_public_data", args: {} })
  .then({ mcp: privateMcp, tool: "store_private_data", args: {} })
  .run();

// Each server uses its own authentication (or none)</code></pre>
          </div>

          <div class="info-box">
            <div class="info-icon">‚ÑπÔ∏è</div>
            <div>
              <strong>MCP Spec Compliance:</strong> Per the official MCP specification, servers use OAuth 2.1 for authentication. Volcano supports both OAuth (automatic token acquisition) and Bearer (bring your own token).
            </div>
          </div>

          <h3>Authentication Features</h3>
          <ul class="benefits-list">
            <li><strong>OAuth token caching:</strong> Tokens are cached and reused until expiration (60s buffer)</li>
            <li><strong>Automatic refresh:</strong> Expired tokens are refreshed automatically</li>
            <li><strong>Per-endpoint configuration:</strong> Each MCP server can have different auth</li>
            <li><strong>Connection pooling:</strong> Authenticated connections are pooled separately</li>
            <li><strong>Spec compliant:</strong> Follows MCP OAuth 2.1 authentication standard</li>
          </ul>
        </section>

        <!-- Connection Pooling -->
        <section id="connection-pooling" class="doc-section">
          <h2>Connection Pooling & Performance</h2>
          <p>Volcano SDK automatically manages MCP connections for optimal performance.</p>
          
          <h3>Connection Pooling</h3>
          <ul class="benefits-list">
            <li><strong>Automatic pooling:</strong> TCP sessions are reused across steps</li>
            <li><strong>LRU eviction:</strong> Idle connections evicted when pool is full</li>
            <li><strong>Per-endpoint pools:</strong> Each MCP server has its own pool</li>
            <li><strong>Auth-aware:</strong> Authenticated connections pooled separately</li>
            <li><strong>Configurable limits:</strong> Max 16 connections, 30s idle timeout (default)</li>
          </ul>

          <h3>Tool Discovery Cache</h3>
          <ul class="benefits-list">
            <li><strong>Cached with TTL:</strong> <code>listTools()</code> results cached for 60s</li>
            <li><strong>Per-endpoint cache:</strong> Each MCP server cached independently</li>
            <li><strong>Invalidation on failure:</strong> Cache cleared if server becomes unavailable</li>
            <li><strong>Reduced latency:</strong> Subsequent requests use cached tool definitions</li>
          </ul>

          <h3>Schema Validation</h3>
          <p>Tool arguments are validated against JSON Schema before execution:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">// If the MCP tool has this schema:
{
  "type": "object",
  "properties": {
    "city": { "type": "string" },
    "units": { "type": "string", "enum": ["celsius", "fahrenheit"] }
  },
  "required": ["city"]
}

// This call would fail validation:
await agent({ llm })
  .then({ 
    mcp: weather, 
    tool: "get_weather", 
    args: { units: "kelvin" }  // ‚ùå Missing required "city", invalid enum
  })
  .run();

// Error: ValidationError
// Message: "arguments failed schema validation: city is required; units must be one of..."</code></pre>
          </div>

          <h3>Configuration</h3>
          <p>Advanced configuration for testing or special scenarios:</p>
          
          <div class="code-block">
            <pre><code class="language-typescript">import { 
  __internal_setPoolConfig,
  __internal_setDiscoveryTtl,
  __internal_clearDiscoveryCache,
  __internal_clearOAuthTokenCache
} from "volcano-sdk";

// Configure connection pool
__internal_setPoolConfig(32, 60_000); // max 32 connections, 60s idle

// Configure tool discovery cache TTL
__internal_setDiscoveryTtl(120_000); // 120s cache

// Clear caches (useful for testing)
__internal_clearDiscoveryCache();
__internal_clearOAuthTokenCache();</code></pre>
          </div>

          <div class="info-box warning">
            <div class="info-icon">‚ö†Ô∏è</div>
            <div>
              <strong>Note:</strong> These are internal APIs for advanced use cases and testing. The default configuration works well for most applications.
            </div>
          </div>
        </section>

      </div>

      <!-- Table of Contents (Right Sidebar) -->
      <aside class="toc">
        <div class="toc-header">On this page</div>
        <nav class="toc-nav" id="toc-nav">
          <!-- Dynamically populated by script.js -->
        </nav>
      </aside>
    </main>
  </div>

  <script src="script.js"></script>
</body>
</html>
