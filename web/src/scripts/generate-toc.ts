import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { slugify } from "../lib/slugify";

export interface Heading {
  level: number;
  text: string;
  id: string;
}

interface DocTOC {
  title: string;
  path: string;
  headings: Heading[];
}

// Extract headings from markdown content
export function extractHeadings(content: string): Heading[] {
  const headings: Heading[] = [];
  const idCounts = new Map<string, number>();

  // Remove code blocks first to avoid matching headings inside them
  const codeBlockRegex = /```[\s\S]*?```/g;
  const contentWithoutCodeBlocks = content.replace(codeBlockRegex, "");

  const headingRegex = /^(#{1,6})\s+(.+)$/gm;
  let match;

  while ((match = headingRegex.exec(contentWithoutCodeBlocks)) !== null) {
    const level = match[1].length;
    const text = match[2].trim();
    let id = slugify(text);

    // Handle duplicate IDs by appending -1, -2, etc. (matching rehype-slug behavior)
    if (idCounts.has(id)) {
      const count = idCounts.get(id)!;
      idCounts.set(id, count + 1);
      id = `${id}-${count}`;
    } else {
      idCounts.set(id, 1);
    }

    headings.push({ level, text, id });
  }

  return headings;
}

// Process a single MDX file
function processMDXFile(filePath: string, relativePath: string): DocTOC | null {
  const content = fs.readFileSync(filePath, "utf-8");
  const { data, content: markdown } = matter(content);

  const headings = extractHeadings(markdown);

  // Skip if no headings
  if (headings.length === 0) return null;

  // Use frontmatter title or first h1 or filename
  const title =
    data.title ||
    headings.find((h) => h.level === 1)?.text ||
    path.basename(filePath, ".mdx");

  // Convert file path to route path
  let routePath = relativePath.replace(/\.mdx$/, "");

  // Handle index files: /index -> /docs, others prepend /docs/
  if (routePath === "/index") {
    routePath = "/docs";
  } else {
    routePath = routePath.replace(/^\//, "/docs/");
  }

  return {
    title,
    path: routePath,
    headings, // Keep all headings for TOC generation
  };
}

// Main generation function
function generateTOC() {
  const docsDir = path.join(process.cwd(), "src/content/docs");
  const outputPath = path.join(
    process.cwd(),
    "src/components/docs/navigation-generated.ts"
  );

  const files = fs
    .readdirSync(docsDir)
    .filter((f: string) => f.endsWith(".mdx"));
  const tocs: DocTOC[] = [];

  for (const file of files) {
    // Skip quickstart.mdx as its content should be in the main docs
    if (file === "quickstart.mdx" || file === "quickstart.md") {
      continue;
    }

    const filePath = path.join(docsDir, file);
    const relativePath = `/${file}`;
    const toc = processMDXFile(filePath, relativePath);

    if (toc) {
      tocs.push(toc);
    }
  }

  // Generate TypeScript output
  const output = `// Auto-generated by generate-toc.ts - DO NOT EDIT MANUALLY
// Run: npm run generate-toc

export interface NavigationHeading {
  level: number
  text: string
  id: string
}

export interface NavigationDoc {
  title: string
  path: string
  headings: NavigationHeading[]
}

export const generatedNavigation: NavigationDoc[] = ${JSON.stringify(tocs, null, 2)}
`;

  fs.writeFileSync(outputPath, output, "utf-8");
  console.log(`âœ… Generated navigation for ${tocs.length} docs`);
  console.log(`ðŸ“ Output: ${outputPath}`);

  // Print summary
  tocs.forEach((toc) => {
    console.log(`\n${toc.path}:`);
    toc.headings.slice(0, 3).forEach((h) => {
      const indent = Math.max(0, h.level - 1); // Prevent negative indents
      console.log(`  ${"  ".repeat(indent)}${h.text} â†’ #${h.id}`);
    });
    if (toc.headings.length > 3) {
      console.log(`  ... and ${toc.headings.length - 3} more`);
    }
  });
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  generateTOC();
}

export { generateTOC };
